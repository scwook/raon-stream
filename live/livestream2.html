<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <title>Mobile WebRTC Camera Publisher</title>
    <style>
        body {
            background-color: #0f0f0f;
            font-family: sans-serif;
            text-align: center;
            padding: 20px;
            color: white;
        }

        video {
            width: 100%;
            max-width: 800px;
            aspect-ratio: 16/9;
            background: #000;
            border-radius: 12px;
        }

        button,
        select,
        input {
            margin: 10px;
            padding: 12px 20px;
            font-size: 16px;
            border-radius: 8px;
            border: none;
        }

        button {
            background: #007AFF;
            color: white;
            cursor: pointer;
            min-width: 120px;
        }

        button:disabled {
            background: #555;
            cursor: not-allowed;
        }

        #stopBtn {
            background: #FF3B30;
            display: none;
        }

        /* Ï§ëÎã® Î≤ÑÌäº Ïä§ÌÉÄÏùº */
        select,
        input {
            background: #333;
            color: white;
            border: 1px solid #555;
        }

        .input-group {
            margin-bottom: 10px;
        }
    </style>
</head>

<body>

    <h2>COSMOS Web Streaming</h2>

    <video id="preview" autoplay playsinline muted controls></video>

    <div class="input-group">
        <input type="text" id="streamName" placeholder="Ïä§Ìä∏Î¶º Ïù¥Î¶Ñ ÏûÖÎ†•">
        <select id="cameraSelect"></select>
    </div>

    <button id="startBtn">Ïπ¥Î©îÎùº ÏºúÍ∏∞</button>
    <button id="publishBtn" disabled>Î∞©ÏÜ° ÏãúÏûë</button>
    <button id="stopBtn">Î∞©ÏÜ° Ï§ëÎã®</button>

    <div id="status">Ï§ÄÎπÑÎê®</div>

    <script>
        const server = "192.168.135.242"; // SRS Ï£ºÏÜå
        const app = "live";

        let localStream = null;
        let pc = null;

        // üìå Ïπ¥Î©îÎùº Î™©Î°ù Î∂àÎü¨Ïò§Í∏∞
        async function loadCameras() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                const devices = await navigator.mediaDevices.enumerateDevices();
                stream.getTracks().forEach(track => track.stop());

                const cams = devices.filter(d => d.kind === "videoinput");
                const select = document.getElementById("cameraSelect");
                select.innerHTML = "";
                cams.forEach(cam => {
                    const op = document.createElement("option");
                    op.value = cam.deviceId;
                    op.text = cam.label || `Ïπ¥Î©îÎùº ${select.length + 1}`;
                    select.appendChild(op);
                });
            } catch (err) {
                console.error("Ïû•Ïπò Î™©Î°ù ÏóêÎü¨:", err);
                document.getElementById("status").innerText = "Ïπ¥Î©îÎùº Í∂åÌïúÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.";
            }
        }

        // üìå Ïπ¥Î©îÎùº ÏºúÍ∏∞
        async function startCamera() {
            const select = document.getElementById("cameraSelect");
            const camId = select.value;
            const camLabel = select.options[select.selectedIndex].text.toLowerCase();

            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }

            // Î™®Î∞îÏùº ÎåÄÏùëÏùÑ ÏúÑÌïú Ï†úÏïΩ Ï°∞Í±¥ ÏÑ§Ï†ï
            const constraints = {
                video: {
                    // deviceIdÍ∞Ä ÏûàÏúºÎ©¥ exactÎ°ú Í∞ïÏ†ú ÏßÄÏ†ï, ÏóÜÏúºÎ©¥ Í∏∞Î≥∏Í∞í
                    deviceId: camId ? { exact: camId } : undefined,
                    // ÎùºÎ≤®Ïóê 'back'Ïù¥ÎÇò 'ÌõÑÎ©¥'Ïù¥ Ìè¨Ìï®ÎêòÏñ¥ ÏûàÏúºÎ©¥ ÌõÑÎ©¥ Î™®Îìú ÌûåÌä∏ Ï†úÍ≥µ
                    facingMode: (camLabel.includes("back") || camLabel.includes("ÌõÑÎ©¥") || camLabel.includes("rear"))
                        ? "environment" : "user"
                },
                audio: true
            };

            try {
                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                document.getElementById("preview").srcObject = localStream;
                document.getElementById("publishBtn").disabled = false;
                document.getElementById("status").innerText = "Ïπ¥Î©îÎùº Ïó∞Í≤∞Îê®";
            } catch (err) {
                console.error("Ïπ¥Î©îÎùº Ï†ÑÌôò ÏóêÎü¨:", err);
                // 'exact'Î°ú Ïã§Ìå®Ìï† Í≤ΩÏö∞(ÏùºÎ∂Ä Íµ¨Ìòï Í∏∞Í∏∞) Îã§Ïãú Ïú†Ïó∞ÌïòÍ≤å ÏãúÎèÑ
                if (err.name === "OverconstrainedError" || err.name === "ConstraintNotSatisfiedError") {
                    document.getElementById("status").innerText = "ÏÑ§Ï†ï Ïò§Î•ò, Í∏∞Î≥∏ Î™®ÎìúÎ°ú Ïû¨ÏãúÎèÑ...";
                    localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                    document.getElementById("preview").srcObject = localStream;
                } else {
                    document.getElementById("status").innerText = `Ïπ¥Î©îÎùº ÏóêÎü¨: ${err.name}`;
                }
            }
        }

        // üìå Î∞©ÏÜ° ÏãúÏûë (WebRTC + WHIP)
        async function publishStream() {
            const streamName = document.getElementById("streamName").value.trim();
            if (!streamName) {
                alert("Ïä§Ìä∏Î¶º Ïù¥Î¶ÑÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.");
                return;
            }

            const whipUrl = `https://${server}:1988/rtc/v1/whip/?app=${app}&stream=${streamName}`;
            document.getElementById("status").innerText = "Î∞©ÏÜ° Ïó∞Í≤∞ Ï§ë...";

            try {
                pc = new RTCPeerConnection({ bundlePolicy: "max-bundle" });

                // Ìä∏Îûô Ï∂îÍ∞Ä
                localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);

                const res = await fetch(whipUrl, {
                    method: "POST",
                    headers: { "Content-Type": "application/sdp" },
                    body: offer.sdp
                });

                if (!res.ok) throw new Error("ÏÑúÎ≤Ñ ÏùëÎãµ ÏóêÎü¨");

                const answerSdp = await res.text();
                await pc.setRemoteDescription({ type: "answer", sdp: answerSdp });

                // UI Ï†ÑÌôò
                document.getElementById("status").innerText = `üì° Î∞©ÏÜ° Ï§ë: ${streamName}`;
                document.getElementById("publishBtn").style.display = "none";
                document.getElementById("stopBtn").style.display = "inline-block";
                document.getElementById("streamName").disabled = true;

            } catch (err) {
                console.error(err);
                document.getElementById("status").innerText = "Î∞©ÏÜ° ÏãúÏûë Ïã§Ìå®";
            }
        }

        // üìå Î∞©ÏÜ° Ï§ëÎã® Î°úÏßÅ
        function stopPublishing() {
            // 1. PeerConnection Îã´Í∏∞
            if (pc) {
                pc.close();
                pc = null;
            }

            // 2. UI Î≥µÍµ¨
            document.getElementById("status").innerText = "Î∞©ÏÜ° Ï§ëÎã®Îê®";
            document.getElementById("publishBtn").style.display = "inline-block";
            document.getElementById("stopBtn").style.display = "none";
            document.getElementById("streamName").disabled = false;

            // Ï∞∏Í≥†: Ïπ¥Î©îÎùº ÏûêÏ≤¥Î•º ÎÅÑÍ≥† Ïã∂Îã§Î©¥ ÏïÑÎûò Ï£ºÏÑù Ìï¥Ï†ú
            /*
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                document.getElementById("preview").srcObject = null;
                document.getElementById("publishBtn").disabled = true;
            }
            */
        }

        document.getElementById("startBtn").onclick = startCamera;
        document.getElementById("publishBtn").onclick = publishStream;
        document.getElementById("stopBtn").onclick = stopPublishing;

        loadCameras();
    </script>
</body>

</html>